#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <intrin.h> 


typedef unsigned int word;
typedef unsigned char byte;


//Delta TABLE은 LFSR을 이용해서 생성
//서브키를 생성시 필요!
const byte delta[128] = {
0x5A,0x6D,0x36,0x1B,0x0D,0x06,0x03,0x41,
0x60,0x30,0x18,0x4C,0x66,0x33,0x59,0x2C,
0x56,0x2B,0x15,0x4A,0x65,0x72,0x39,0x1C,
0x4E,0x67,0x73,0x79,0x3C,0x5E,0x6F,0x37,
0x5B,0x2D,0x16,0x0B,0x05,0x42,0x21,0x50,
0x28,0x54,0x2A,0x55,0x6A,0x75,0x7A,0x7D,
0x3E,0x5F,0x2F,0x17,0x4B,0x25,0x52,0x29,
0x14,0x0A,0x45,0x62,0x31,0x58,0x6C,0x76,
0x3B,0x1D,0x0E,0x47,0x63,0x71,0x78,0x7C,
0x7E,0x7F,0x3F,0x1F,0x0F,0x07,0x43,0x61,
0x70,0x38,0x5C,0x6E,0x77,0x7B,0x3D,0x1E,
0x4F,0x27,0x53,0x69,0x34,0x1A,0x4D,0x26,
0x13,0x49,0x24,0x12,0x09,0x04,0x02,0x01,
0x40,0x20,0x10,0x08,0x44,0x22,0x11,0x48,
0x64,0x32,0x19,0x0C,0x46,0x23,0x51,0x68,
0x74,0x3A,0x5D,0x2E,0x57,0x6B,0x35,0x5A };


//F0,F1연산을 미리 look up table로 구성해놓으면 고속화 연산이 가능
const byte F0[256] = {
0x00, 0x86, 0x0d, 0x8b, 0x1a, 0x9c, 0x17, 0x91, 0x34, 0xb2, 0x39, 0xbf, 0x2e, 0xa8, 0x23, 0xa5,
0x68, 0xee, 0x65, 0xe3, 0x72, 0xf4, 0x7f, 0xf9, 0x5c, 0xda, 0x51, 0xd7, 0x46, 0xc0, 0x4b, 0xcd,
0xd0, 0x56, 0xdd, 0x5b, 0xca, 0x4c, 0xc7, 0x41, 0xe4, 0x62, 0xe9, 0x6f, 0xfe, 0x78, 0xf3, 0x75,
0xb8, 0x3e, 0xb5, 0x33, 0xa2, 0x24, 0xaf, 0x29, 0x8c, 0x0a, 0x81, 0x07, 0x96, 0x10, 0x9b, 0x1d,
0xa1, 0x27, 0xac, 0x2a, 0xbb, 0x3d, 0xb6, 0x30, 0x95, 0x13, 0x98, 0x1e, 0x8f, 0x09, 0x82, 0x04,
0xc9, 0x4f, 0xc4, 0x42, 0xd3, 0x55, 0xde, 0x58, 0xfd, 0x7b, 0xf0, 0x76, 0xe7, 0x61, 0xea, 0x6c,
0x71, 0xf7, 0x7c, 0xfa, 0x6b, 0xed, 0x66, 0xe0, 0x45, 0xc3, 0x48, 0xce, 0x5f, 0xd9, 0x52, 0xd4,
0x19, 0x9f, 0x14, 0x92, 0x03, 0x85, 0x0e, 0x88, 0x2d, 0xab, 0x20, 0xa6, 0x37, 0xb1, 0x3a, 0xbc,
0x43, 0xc5, 0x4e, 0xc8, 0x59, 0xdf, 0x54, 0xd2, 0x77, 0xf1, 0x7a, 0xfc, 0x6d, 0xeb, 0x60, 0xe6,
0x2b, 0xad, 0x26, 0xa0, 0x31, 0xb7, 0x3c, 0xba, 0x1f, 0x99, 0x12, 0x94, 0x05, 0x83, 0x08, 0x8e,
0x93, 0x15, 0x9e, 0x18, 0x89, 0x0f, 0x84, 0x02, 0xa7, 0x21, 0xaa, 0x2c, 0xbd, 0x3b, 0xb0, 0x36,
0xfb, 0x7d, 0xf6, 0x70, 0xe1, 0x67, 0xec, 0x6a, 0xcf, 0x49, 0xc2, 0x44, 0xd5, 0x53, 0xd8, 0x5e,
0xe2, 0x64, 0xef, 0x69, 0xf8, 0x7e, 0xf5, 0x73, 0xd6, 0x50, 0xdb, 0x5d, 0xcc, 0x4a, 0xc1, 0x47,
0x8a, 0x0c, 0x87, 0x01, 0x90, 0x16, 0x9d, 0x1b, 0xbe, 0x38, 0xb3, 0x35, 0xa4, 0x22, 0xa9, 0x2f,
0x32, 0xb4, 0x3f, 0xb9, 0x28, 0xae, 0x25, 0xa3, 0x06, 0x80, 0x0b, 0x8d, 0x1c, 0x9a, 0x11, 0x97,
0x5a, 0xdc, 0x57, 0xd1, 0x40, 0xc6, 0x4d, 0xcb, 0x6e, 0xe8, 0x63, 0xe5, 0x74, 0xf2, 0x79, 0xff
};

const byte F1[256] = {
0x00, 0x58, 0xb0, 0xe8, 0x61, 0x39, 0xd1, 0x89, 0xc2, 0x9a, 0x72, 0x2a, 0xa3, 0xfb, 0x13, 0x4b,
0x85, 0xdd, 0x35, 0x6d, 0xe4, 0xbc, 0x54, 0x0c, 0x47, 0x1f, 0xf7, 0xaf, 0x26, 0x7e, 0x96, 0xce,
0x0b, 0x53, 0xbb, 0xe3, 0x6a, 0x32, 0xda, 0x82, 0xc9, 0x91, 0x79, 0x21, 0xa8, 0xf0, 0x18, 0x40,
0x8e, 0xd6, 0x3e, 0x66, 0xef, 0xb7, 0x5f, 0x07, 0x4c, 0x14, 0xfc, 0xa4, 0x2d, 0x75, 0x9d, 0xc5,
0x16, 0x4e, 0xa6, 0xfe, 0x77, 0x2f, 0xc7, 0x9f, 0xd4, 0x8c, 0x64, 0x3c, 0xb5, 0xed, 0x05, 0x5d,
0x93, 0xcb, 0x23, 0x7b, 0xf2, 0xaa, 0x42, 0x1a, 0x51, 0x09, 0xe1, 0xb9, 0x30, 0x68, 0x80, 0xd8,
0x1d, 0x45, 0xad, 0xf5, 0x7c, 0x24, 0xcc, 0x94, 0xdf, 0x87, 0x6f, 0x37, 0xbe, 0xe6, 0x0e, 0x56,
0x98, 0xc0, 0x28, 0x70, 0xf9, 0xa1, 0x49, 0x11, 0x5a, 0x02, 0xea, 0xb2, 0x3b, 0x63, 0x8b, 0xd3,
0x2c, 0x74, 0x9c, 0xc4, 0x4d, 0x15, 0xfd, 0xa5, 0xee, 0xb6, 0x5e, 0x06, 0x8f, 0xd7, 0x3f, 0x67,
0xa9, 0xf1, 0x19, 0x41, 0xc8, 0x90, 0x78, 0x20, 0x6b, 0x33, 0xdb, 0x83, 0x0a, 0x52, 0xba, 0xe2,
0x27, 0x7f, 0x97, 0xcf, 0x46, 0x1e, 0xf6, 0xae, 0xe5, 0xbd, 0x55, 0x0d, 0x84, 0xdc, 0x34, 0x6c,
0xa2, 0xfa, 0x12, 0x4a, 0xc3, 0x9b, 0x73, 0x2b, 0x60, 0x38, 0xd0, 0x88, 0x01, 0x59, 0xb1, 0xe9,
0x3a, 0x62, 0x8a, 0xd2, 0x5b, 0x03, 0xeb, 0xb3, 0xf8, 0xa0, 0x48, 0x10, 0x99, 0xc1, 0x29, 0x71,
0xbf, 0xe7, 0x0f, 0x57, 0xde, 0x86, 0x6e, 0x36, 0x7d, 0x25, 0xcd, 0x95, 0x1c, 0x44, 0xac, 0xf4,
0x31, 0x69, 0x81, 0xd9, 0x50, 0x08, 0xe0, 0xb8, 0xf3, 0xab, 0x43, 0x1b, 0x92, 0xca, 0x22, 0x7a,
0xb4, 0xec, 0x04, 0x5c, 0xd5, 0x8d, 0x65, 0x3d, 0x76, 0x2e, 0xc6, 0x9e, 0x17, 0x4f, 0xa7, 0xff
};






//key schedule
//Key: whitening key / Sub key
//Whitening key : 8-bit * 8개
//Sub key: 8-bit * 128개
//main 함수에서 각각 만들어서 enc, dec에 각각 넘겨줘!!!
//byte mk[16]
//byte wk[8]
//byte sk[128]
void key_schedule(byte* mk, byte* wk, byte* sk) {
	//wk 생성
	wk[0] = mk[3];
	wk[1] = mk[2];
	wk[2] = mk[1];
	wk[3] = mk[0];

	wk[4] = mk[15];
	wk[5] = mk[14];
	wk[6] = mk[13];
	wk[7] = mk[12];


	//sk 생성
	int i, j;
	for (i = 0; i < 8; i++) {
		for (j = 0; j < 8; j++) {
			//음수에 대한 mod는 c언어에서 연산이 잘 안됨 -> 이 부분 주의
			//(j - i) % 8 -> (j - i + 8) % 8
			sk[16 * i + j] = (mk[15 - ((j - i + 8) % 8)] + delta[16 * i + j]);
		}

		for (j = 0; j < 8; j++) {
			//음수에 대한 mod는 c언어에서 연산이 잘 안됨 -> 이 부분 주의
			//(j - i) % 8 -> (j - i + 8) % 8
			sk[16 * i + j + 8] = (mk[15 - (((j - i + 8) % 8) + 8)] + delta[16 * i + j + 8]);
		}
	}
}



//암호화과정 초기변환 단계
//input값을 update하는 방향으로 진행
//byte input[8], byte wk[8]
void ENC_F_TRANSFORM(byte* input, byte* wk) {
	//input 1,3,5,7은 그대로
	//0,2,4,6 변환

	input[7] = (input[7] + wk[0]);
	input[5] ^= wk[1];
	input[3] = (input[3] + wk[2]);
	input[1] ^= wk[3];
}

//암호화과정 최종변환 단계
//input값을 update하는 방향으로 진행
//byte input[8], byte wk[8]
void ENC_L_TRANSFORM(byte* input, byte* wk) {
	//input 1,3,5,7은 그대로
	//0,2,4,6 변환
	input[7] = (input[7] + wk[4]);
	input[5] ^= wk[5];
	input[3] = (input[3] + wk[6]);
	input[1] ^= wk[7];
}



//복호화 초기변환 단계
//input값을 update하는 방향으로 진행
//byte input[8], byte wk[8]
void DEC_F_TRANSFORM(byte* input, byte* wk) {
	//input 1,3,5,7은 그대로
	
	//0,2,4,6 변환
	input[7] = (input[7] - wk[4]);
	input[5] ^= wk[5];
	input[3] = (input[3] - wk[6]);
	input[1] ^= wk[7];
}


//복호화과정 최종변환 단계
//input값을 update하는 방향으로 진행
//byte input[8], byte wk[8]
void DEC_L_TRANSFORM(byte* input, byte* wk) {
	//input 1,3,5,7은 그대로
	
	//0,2,4,6 변환
	input[7] = (input[7] - wk[0]);
	input[5] ^= wk[1];
	input[3] = (input[3] - wk[2]);
	input[1] ^= wk[3];
}



//암호화
//1R ~ 31R 함수
//byte input[8] / byte sk[128]
void enc_round_func(byte* input, byte* sk, int round) {
	//계산연산이 꼬이지 않기 위해서 temp배열 생성
	byte temp[8] = { 0, };
	memcpy(temp, input, 8 * sizeof(byte));

	//input 1, 3, 5, 7
	input[6] = temp[7];
	input[4] = temp[5];
	input[2] = temp[3];
	input[0] = temp[1];


	//input 0, 2, 4, 6
	input[7] = (temp[0] ^ (F0[temp[1]] + sk[4 * round - 1]));
	input[5] = (temp[6] + (F1[temp[7]] ^ sk[4 * round - 4]));
	input[3] = (temp[4] ^ (F0[temp[5]] + sk[4 * round - 3]));
	input[1] = (temp[2] + (F1[temp[3]] ^ sk[4 * round - 2]));
}


//암호화
//32R
//byte input[8] / byte sk[128]
void enc_last_round(byte* input, byte* sk) {
	//계산연산이 꼬이지 않기 위해서 temp배열 생성
	byte temp[8] = { 0, };
	memcpy(temp, input, 8 * sizeof(byte));



	//input 0, 2, 4, 6
	input[7] = temp[7];
	input[5] = temp[5];
	input[3] = temp[3];
	input[1] = temp[1];



	//input 1, 3, 5, 7
	input[6] = (temp[6] + (F1[temp[7]] ^ sk[124]));
	input[4] = (temp[4] ^ (F0[temp[5]] + sk[125]));
	input[2] = (temp[2] + (F1[temp[3]] ^ sk[126]));
	input[0] = (temp[0] ^ (F0[temp[1]] + sk[127]));
}



//복호화
//1R ~ 31R 함수
//byte input[8] / byte sk[128]
void dec_round_func(byte* input, byte* sk, int round) {
	//계산연산이 꼬이지 않기 위해서 temp배열 생성
	byte temp[8] = { 0, };
	memcpy(temp, input, 8 * sizeof(byte));

	//input 1, 3, 5, 7
	input[6] = temp[5];
	input[4] = temp[3];
	input[2] = temp[1];
	input[0] = temp[7];


	//input 0, 2, 4, 6
	input[7] = (temp[6] - (F1[temp[7]] ^ sk[127 - (4 * round - 1)]));
	input[5] = (temp[4] ^ (F0[temp[5]] + sk[127 - (4 * round - 2)]));
	input[3] = (temp[2] - (F1[temp[3]] ^ sk[127 - (4 * round - 3)]));
	input[1] = (temp[0] ^ (F0[temp[1]] + sk[127 - (4 * round - 4)]));
}

//복호화
//32R
//byte input[8] / byte sk[128]
void dec_last_round(byte* input, byte* sk) {
	//계산연산이 꼬이지 않기 위해서 temp배열 생성
	byte temp[8] = { 0, };
	memcpy(temp, input, 8 * sizeof(byte));



	//input 0, 2, 4, 6
	input[7] = temp[7];
	input[5] = temp[5];
	input[3] = temp[3];
	input[1] = temp[1];



	//input 1, 3, 5, 7
	input[6] = (temp[6] - (F1[temp[7]] ^ sk[0]));
	input[4] = (temp[4] ^ (F0[temp[5]] + sk[1]));
	input[2] = (temp[2] - (F1[temp[3]] ^ sk[2]));
	input[0] = (temp[0] ^ (F0[temp[1]] + sk[3]));
}


//암호화 
//초기변환
//1R ~ 32R
//최종변환
void HIGHT_ENC(byte* pt, byte* wk, byte* sk, byte* ct) {
	//pt(평문)은 연산진행에서 바뀌면 안되기 때문에
	//temp_pt에 pt값을 옮겨 담아서 연산을 진행하면서
	//temp_pt를 암호문으로 바꿔나아갈 것!
	byte temp_pt[8] = { 0, };
	memcpy(temp_pt, pt, 8 * sizeof(byte));


	//초기변환
	ENC_F_TRANSFORM(temp_pt, wk);

	//1R ~ 32R
	enc_round_func(temp_pt, sk, 1);
	enc_round_func(temp_pt, sk, 2);
	enc_round_func(temp_pt, sk, 3);
	enc_round_func(temp_pt, sk, 4);


	enc_round_func(temp_pt, sk, 5);
	enc_round_func(temp_pt, sk, 6);
	enc_round_func(temp_pt, sk, 7);
	enc_round_func(temp_pt, sk, 8);


	enc_round_func(temp_pt, sk, 9);
	enc_round_func(temp_pt, sk, 10);
	enc_round_func(temp_pt, sk, 11);
	enc_round_func(temp_pt, sk, 12);


	enc_round_func(temp_pt, sk, 13);
	enc_round_func(temp_pt, sk, 14);
	enc_round_func(temp_pt, sk, 15);
	enc_round_func(temp_pt, sk, 16);


	enc_round_func(temp_pt, sk, 17);
	enc_round_func(temp_pt, sk, 18);
	enc_round_func(temp_pt, sk, 19);
	enc_round_func(temp_pt, sk, 20);


	enc_round_func(temp_pt, sk, 21);
	enc_round_func(temp_pt, sk, 22);
	enc_round_func(temp_pt, sk, 23);
	enc_round_func(temp_pt, sk, 24);


	enc_round_func(temp_pt, sk, 25);
	enc_round_func(temp_pt, sk, 26);
	enc_round_func(temp_pt, sk, 27);
	enc_round_func(temp_pt, sk, 28);


	enc_round_func(temp_pt, sk, 29);
	enc_round_func(temp_pt, sk, 30);
	enc_round_func(temp_pt, sk, 31);


	enc_last_round(temp_pt, sk);


	//최종변환
	ENC_L_TRANSFORM(temp_pt, wk);



	//마지막 처리
	//temp_pt에 암호문이 저장 되어있기 때문에
	//ct에 memcpy를 통해서 암호문을 옮겨줌
	memcpy(ct, temp_pt, 8 * sizeof(byte));
}

//복호화 
//초기변환
//1R ~ 32R
//최종변환
void HIGHT_DEC(byte* ct, byte* wk, byte* sk, byte* dec_pt) {
	//ct(암호문)은 연산진행에서 바뀌면 안되기 때문에
	//temp_ct에 ct값을 옮겨 담아서 연산을 진행하면서
	//temp_ct를 복호화된 결과값으로 바꿔나아갈 것!
	byte temp_ct[8] = { 0, };
	memcpy(temp_ct, ct, 8 * sizeof(byte));


	//초기변환
	DEC_F_TRANSFORM(temp_ct, wk);

	//1R ~ 32R
	dec_round_func(temp_ct, sk, 1);
	dec_round_func(temp_ct, sk, 2);
	dec_round_func(temp_ct, sk, 3);
	dec_round_func(temp_ct, sk, 4);


	dec_round_func(temp_ct, sk, 5);
	dec_round_func(temp_ct, sk, 6);
	dec_round_func(temp_ct, sk, 7);
	dec_round_func(temp_ct, sk, 8);


	dec_round_func(temp_ct, sk, 9);
	dec_round_func(temp_ct, sk, 10);
	dec_round_func(temp_ct, sk, 11);
	dec_round_func(temp_ct, sk, 12);


	dec_round_func(temp_ct, sk, 13);
	dec_round_func(temp_ct, sk, 14);
	dec_round_func(temp_ct, sk, 15);
	dec_round_func(temp_ct, sk, 16);


	dec_round_func(temp_ct, sk, 17);
	dec_round_func(temp_ct, sk, 18);
	dec_round_func(temp_ct, sk, 19);
	dec_round_func(temp_ct, sk, 20);


	dec_round_func(temp_ct, sk, 21);
	dec_round_func(temp_ct, sk, 22);
	dec_round_func(temp_ct, sk, 23);
	dec_round_func(temp_ct, sk, 24);


	dec_round_func(temp_ct, sk, 25);
	dec_round_func(temp_ct, sk, 26);
	dec_round_func(temp_ct, sk, 27);
	dec_round_func(temp_ct, sk, 28);


	dec_round_func(temp_ct, sk, 29);
	dec_round_func(temp_ct, sk, 30);
	dec_round_func(temp_ct, sk, 31);


	dec_last_round(temp_ct, sk);


	//최종변환
	DEC_L_TRANSFORM(temp_ct, wk);



	//마지막 처리
	//temp_ct에 복호화된 결과값이 저장 되어있기 때문에
	//dec_pt에 memcpy를 통해서 암호문을 옮겨줌
	memcpy(dec_pt, temp_ct, 8 * sizeof(byte));
}


int main() {
	//test vector
	//kisa hight test vector
	byte pt[8] = { 0, };
	byte key[16] = { 0x00,0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88,0x99,0xaa,0xbb,0xcc,0xdd,0xee,0xff };
	byte ct[8] = { 0, };
	byte dec_pt[8] = { 0, };


	//wk, sk 생성
	byte wk[8] = { 0, };
	byte sk[128] = { 0, };
	key_schedule(key, wk, sk);

	//encryption
	HIGHT_ENC(pt, wk, sk, ct);

	//decryption
	HIGHT_DEC(ct, wk, sk, dec_pt);


	//출력
	int i;
	//암호화된 결과값 출력
	printf("CT: ");
	for (i = 0; i < 8; i++) {
		printf("%02x ", ct[i]);
	}

	//복호화된 결과값 출력
	printf("\nDEC_PT: ");
	for (i = 0; i < 8; i++) {
		printf("%02x ", dec_pt[i]);
	}

}



